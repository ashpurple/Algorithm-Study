# DP

가능한 최대 경우의 수는 3가지로 1을 빼주는 것은 모든 경우에서 가능하고<br>
2의 배수이면 2로 나눌 수 있고 3의 배수이면 3으로 나눌 수 있다.

따라서 2부터 연산의 최솟값을 dp table에 저장해두며 해당 값까지 증가 시켰다.<br>
- `dp[i] = dp[i - 1] + 1` 1을 뺄 때의 연산 횟수 (default)
- `dp[i] = min(dp[i / 3] + 1, dp[i])` 3으로 나눌 때의 연산 횟수
- `dp[i] = min(dp[i / 2] + 1, dp[i])` 2로 나눌 때의 연산 횟수

N 은 결국 2부터 N-1 까지의 수들의 연산 합으로 이루어져 있으므로 dp적 풀이가 가능하다

수의 history는 dp 값을 갱신할 때 cache 에다 넣어주었고 해당 cache 값에 따라
queue를 이용해 backtracking 방식으로 추적하였다.

cache[0] -> 2로 나눠서 구현되었는지

cache[1] => 3으로 나눠서 구현되었는지
