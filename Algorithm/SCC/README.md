# SCC (Strongly Connected Component)
![68747470733a2f2f7777772e676c6f62616c736f667477617265737570706f72742e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f30332f657a6769662e636f6d2d766964656f2d746f2d6769662d33362e676966](https://user-images.githubusercontent.com/75887645/156882053-1456d652-b378-45d8-82bb-01f037506036.gif)
![68747470733a2f2f7777772e676c6f62616c736f667477617265737570706f72742e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f30332f657a6769662e636f6d2d766964656f2d746f2d6769662d33372e676966](https://user-images.githubusercontent.com/75887645/156882078-cfcdf873-0f35-408c-a87d-f872e587d65a.gif)


<정의 및 활용>
- 방향 그래프에서 사이클 그룹을 구하는 알고리즘
- u 에서 v로 갈 수있고 v에서도 u로 갈 수 있을 때 u와 v는 '강하게 연결되었다'라고 한다
- 재귀 노드 또한 다른 사이클의 집합이 될 수 있다
- 코사라주 알고리즘: 순방향과 역방향 그래프를 dfs로 탐색
- 시간복잡도 `O(V + E)`

<코사라주 알고리즘>
1. 입력을 받을 때 역방향을 나타내는 `r_edge`에도 입력을 받는다
2. `dfs(cur)`로 순방향 그래프를 탐색하며 가장 깊은 노드부터 stack에 넣어준다
3. `r_dfs(cur, groupNum)`로 역방향 그래프를 탐색하며 stack pop을 통해 탐색 노드에 그룹 번호를 부여한다
=> ex) pop node = 1 일때 1에서 r_dfs 수행 -> 방문 노드 같은 번호 부여
4. `groupNum`은 사이클 그룹의 개수, `ssc[i]`는 i의 그룹 번호를 의미한다
