# 2022 SAMSUNG SDS Winter Algorithm Study
## Index
1. [알고리즘기초](#Day1,-Day2-알고리즘-기초)
2. [자료구조](#Day3-자료구조)
3. [정수론](#Day4-정수론)

## Day1, Day2 알고리즘 기초

### 알고리즘
- 알고리즘은 완전탐색으로 시작해 조건과 시간 복잡도에 따라 개선
- 조건: 정밀성, 유일성, 입출력, 유한성, 일반성
- 필요역량: 구현력(반복연습), 이론(학습), 응용력(문제풀이)
### DFS
- stack overflow 유의
- 백트래킹, 단절선 찾기, 위상정렬, 사이클 찾기 등에서 활용
### BFS
- 최단경로 찾기, 위상정렬 등에서 활용
- 최단 경로는 parent를 이용해 추적
### 완전탐색
- 알고리즘은 완전탐색에서부터 시작
- 시간복잡도가 크다면 개선하여 작게 만드는 것이 목표
### 재귀함수
- 하나의 문제를 여러 부분문제로 나누어 해결 (divide & conquer)
### 정렬
- 유일성 검사 / 중복제거 : 인접한 데이터와의 비교
- 빈도구하기: 정렬된 데이터를 한번씩만 확인하면 빈도 수 확인 가능
- 합집합 / 교집합: 2 pointers 알고리즘 이용
### Cycle Detect
- visited flag 하나만으로는 사이클 판별 불가
- unvisited, explored, visited 3개의 상태로 판별
- unvisited 면서 explored된 노드 만날 시 cycle (Back Edge)
### 이분탐색
- off-by-one error 주의
- lower bound(이상) / upper bound(초과)
### 시간복잡도
- 반복문의 범위나 중첩 되어있는 반복문의 개수를 보고 판단
- 통상적으로 1억 = 1초
- 일반적으로 빅-오 표기법을 사용, 최고차항의 차수만 표기


## Day3 자료구조
### 개요
- 자료구조란 효율적으로 접근하고 수정할 수 있도록 데이터를 구성하고 저장하는 방법
- Tree는 사이클이 없는 그래프로 루트노드로부터 계층 구조를 이룸
- 구간합은 누적합으로 해결가능
- 선형 자료구조: 배열, 연결 리스트, 스택, 큐
- 비선형 자료구조: 트리, 그래프
### 배열
- 데이터 접근이 용이, 삽입/삭제가 어려움, 구조가 간단함
### 연결리스트
- 각 노드가 데이터와 포인터를 가지고 연결
- 데이터 접근이 느림, 삽입/삭제 빠름, 구조가 어려움 => 배열과 반대
### 스택
- 삽입과 삭제가 한 방향에서 이루어지는 선형 자료구조
- LIFO
### 큐
- 한방향에선 삽입 반대편에서 삭제가 이루어지는 선형 자료구조
- FIFO
- 양방향에서 삽입 삭제가 모두 이루어지는 큐를 덱(Deque)이라고 한다.
### 트리
- 부모 자식관게로 표현되는 계층적 자료구조
- 트리의 부분트리 또한 트리구조를 따름
### 이진트리
- 분지 수가 2 이하인 트리
- 높이가 N인 이진 트리의 최대 노드 개수 2^N – 1
- Pre-order: 현재방문-왼쪽자식-오른쪽자식
- In-order: 왼쪽자식 - 현재방문 – 오른쪽자식
- Post-order: 왼쪽자식 – 오른쪽자식 – 현재방문
### 힙
- 힙 조건을 만족하는 완전 이진트리
- 힙 조건: 각 노드의 키 값은 자식 노드의 키 값보다 크다 (또는 작다)
- 일차원 배열로 구현
- 그룹 정렬이나 최소/최대 값을 찾을 때 사용
- 삽입/삭제 수행시간 `O(logN)`
### Index Tree
- <b>SDS pro 빈출 자료구조</b>
- 포화 이진트리
- 리프노드: 배열에 적혀있는 수 / 내부 노드: 왼쪽과 오른쪽 자식의 합
- 구성 시 N <= 2^T를 만족하는 T층의 트리 배열을 만든다
- 노드개수는 꽉 찬 트리에서 2N개
- 수정이 빈번하게 일어나는 구간합 문제에서 효율적 
- 탐색 및 수정 `O(logN)`, M번 탐색 또는 수정 `O(MlogN)`
- Bottom Up 방식으로 구현
### Segment Tree
- 기본 이론은 Index트리와 비슷하지만 구성 시 모양이 상이할 수 있음
- Top Down 방식으로 구현
- 데이터 삽입 시 Post-order 방식
- Range Update 가능 (Index Tree는 불가능) => Range Propagation 사용 (flag를 이용한 delay)
- 루트가 전체 범위에 대한 대표 값을 가지고 자식들이 범위를 반씩 나누어 대표 값을 저장
- 부모의 범위를 반씩 나누어 자식들이 해당 범위의 대표 값을 저장
- Leaf노드의 Index번호를 따로 구해야 함
- 범위를 반씩 나누어 가지기 때문에 Leaf노드의 Index번호가 어떻게 나올지 모름
- Index 구해서 따로 index저장 배열에 저장해야 함
### Fenwick Tree (Binary Index Tree)
- 구간의 대표 값(주로 합, 최대/최소는 특성상 어려움)을 bit 연산으로 구할 수 있음
- 트리 공간이 데이터 개수와 같은 N개만 있으면 됨
- 각 Index를 2진수로 표현했을 때, '1'이 존재하는 가장 최하위 비트의 값을 찾는다 (x값)
- 해당 Index부터 x칸 앞까지의 구간연산에 대한 결과값을 갖는다
- v&-v을 수행하면 2진수 기준으로 가장 오른쪽 1이 나오게 됨
### 트라이
- 문자열을 빠르게 검색할 수 있는 자료구조
- 트라이의 Root 노드는 항상 공백문자열 상태를 의미함
- 첫글자부터 탐색하여 철자에 해당하는 자식으로 이동하는 방식
### 해싱
- 입력된 데이터를 해시 함수를 통해 얻은 주소로부터 위치를 직접 참조
- 버킷과 슬롯으로 구성된 해시 테이블 사용
- O(1)의 시간 복잡도
### 셋
- 모든 key가 유일한 자료구조
- 해시 셋: 해싱을 이용하여 데이터를 저장, `O(1)`
- 트리 셋: 레드 블랙 트리로 구현, <b>정렬된 순서</b>로 불러옴 `O(logN)`
### 맵
- key와 value로 이루어진 <b>객체</b>를 저장하는 자료구조
- 특징은 셋과 동일함

## Day4 정수론
### 합동식
- a ≡ b (mod p) => b ≡ a (mod p)
- a ≡ b (mod p), b ≡ c (mod p) => a ≡ c (mod p)
### 유클리드 호제법
- gcd(a, b) = gcd(b, a%b)
- ex) gcd(36, 24) = gcd(24, 12) = gcd(12, 0) => 12
### 확장 유클리드 호제법
- ax + by = c 형태의 방정식을 만족시키는 x, y를 s, y라 할 때 유클리드 호제법을 사용하여 반복적으로 구하면 정수 해 s와 t가 반드시 존재한다
- as + bt = gcd(a, b)
 
![image](https://user-images.githubusercontent.com/75887645/148342475-78d05d11-58bc-4b89-8c22-3bd537fb069f.png)

### 오일러 함수
- φ(n): n보다 작은 n과 서로소인 수들의 개수
- n이 소수이면 φ(n) = n-1
- a와 b가 서로소 일 때 φ(뮤) = φ(a) * φ(b)
### 에라토니스테니스의 채
- 범위내의 모든 소수를 구할 때 사용
- 어떤 수가 소수인지 판단할 때는 짝수를 제외한 √n까지만 검사 (isPrime)
- n이하의 모든 소수는 √n이하의 배수들을 지워가며 체크

